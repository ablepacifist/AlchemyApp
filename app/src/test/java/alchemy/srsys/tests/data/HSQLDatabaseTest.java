package alchemy.srsys.tests.data;

import org.junit.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.sql.*;
import java.util.*;
import java.lang.reflect.Field;

import alchemy.srsys.data.HSQLDatabase;
import alchemy.srsys.object.Effect;
import alchemy.srsys.object.IEffect;
import alchemy.srsys.object.IIngredient;
import alchemy.srsys.object.IInventory;
import alchemy.srsys.object.IKnowledgeBook;
import alchemy.srsys.object.Ingredient;
import alchemy.srsys.object.Inventory;
import alchemy.srsys.object.KnowledgeBook;
import alchemy.srsys.object.Player;
import alchemy.srsys.object.Potion;

public class HSQLDatabaseTest {

    private HSQLDatabase db;
    private String dbPath;

    // Helper method to access the private "connection" field via reflection.
    private Connection getConnection() throws Exception {
        Field field = HSQLDatabase.class.getDeclaredField("connection");
        field.setAccessible(true);
        return (Connection) field.get(db);
    }

    @Before
    public void setUp() throws Exception {
        // Create a unique temporary database name.
        dbPath = "testdb_" + System.currentTimeMillis();
        db = new HSQLDatabase(dbPath);

        // Create the required tables for testing.
        Connection conn = getConnection();
        Statement stmt = conn.createStatement();

        // Create EFFECTS table.
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS effects ("
                + "id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
                + "title VARCHAR(255) NOT NULL, "
                + "description VARCHAR(255))");

        // Create INGREDIENTS table.
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS ingredients ("
                + "id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
                + "name VARCHAR(255) NOT NULL)");

        // Create POTIONS table.
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS potions ("
                + "id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
                + "name VARCHAR(255) NOT NULL, "
                + "ingredient1_id INTEGER, "
                + "ingredient2_id INTEGER, "
                + "FOREIGN KEY (ingredient1_id) REFERENCES ingredients(id), "
                + "FOREIGN KEY (ingredient2_id) REFERENCES ingredients(id))");

        // Create PLAYER_POTIONS table.
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS player_potions ("
                + "player_id INTEGER NOT NULL, "
                + "potion_id INTEGER NOT NULL, "
                + "quantity INTEGER NOT NULL, "
                + "PRIMARY KEY (player_id, potion_id), "
                + "FOREIGN KEY (potion_id) REFERENCES potions(id))");

        // Create PLAYER_INVENTORY table for ingredients.
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS player_inventory ("
                + "player_id INTEGER NOT NULL, "
                + "ingredient_id INTEGER NOT NULL, "
                + "quantity INTEGER NOT NULL, "
                + "PRIMARY KEY (player_id, ingredient_id), "
                + "FOREIGN KEY (ingredient_id) REFERENCES ingredients(id))");

        // Create POTION_EFFECTS table.
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS potion_effects ("
                + "potion_id INTEGER NOT NULL, "
                + "effect_id INTEGER NOT NULL, "
                + "PRIMARY KEY (potion_id, effect_id), "
                + "FOREIGN KEY (potion_id) REFERENCES potions(id), "
                + "FOREIGN KEY (effect_id) REFERENCES effects(id))");

        stmt.close();
    }


    @After
    public void tearDown() {
        if (db != null) {
            db.close();
        }
    }

    // 1. getNextPotionId()
    @Test
    public void testGetNextPotionId() {
        int nextPotionId = db.getNextPotionId();
        assertEquals("Next potion id should be 1 when none exists", 1, nextPotionId);

        try {
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO potions (id, name) VALUES (?, ?)");
            pstmt.setInt(1, 1);
            pstmt.setString(2, "Test Potion");
            pstmt.executeUpdate();
            pstmt.close();
        } catch (Exception e) {
            fail("Exception during manual potion insert: " + e.getMessage());
        }

        int nextAfter = db.getNextPotionId();
        assertEquals("After inserting one potion, next potion id should be 2", 2, nextAfter);
    }

    // 2. getNextPlayerId()
    @Test
    public void testGetNextPlayerId() {
        int nextPlayerId = db.getNextPlayerId();
        assertEquals("Next player id should be 1 when table is empty", 1, nextPlayerId);

        Player player = new Player(nextPlayerId, "user1", "pass", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        int nextAfter = db.getNextPlayerId();
        assertEquals("After adding one player, next player id should be 2", 2, nextAfter);
    }

    // 3. getIngredientByName(String name)
    @Test
    public void testGetIngredientByName() {
        try {
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO ingredients (NAME) VALUES (?)");
            pstmt.setString(1, "Herb");
            pstmt.executeUpdate();
            pstmt.close();
        } catch(Exception e) {
            fail("Exception inserting ingredient: " + e.getMessage());
        }
        IIngredient ing = db.getIngredientByName("Herb");
        assertNotNull("Ingredient should be found", ing);
        assertEquals("Ingredient name should be 'Herb'", "Herb", ing.getName());
    }

    // 4. getAllIngredients()
    @Test
    public void testGetAllIngredients() {
        try {
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO ingredients (NAME) VALUES (?)");
            pstmt.setString(1, "Herb");
            pstmt.executeUpdate();
            pstmt.setString(1, "Mushroom");
            pstmt.executeUpdate();
            pstmt.close();
        } catch(Exception e) {
            fail("Exception inserting ingredients: " + e.getMessage());
        }
        List<IIngredient> ingredients = db.getAllIngredients();
        assertTrue("Ingredients list should contain 'Herb'",
                ingredients.stream().anyMatch(ing -> ing.getName().equalsIgnoreCase("Herb")));
        assertTrue("Ingredients list should contain 'Mushroom'",
                ingredients.stream().anyMatch(ing -> ing.getName().equalsIgnoreCase("Mushroom")));
    }

    // 5. addPlayer(Player player)
    @Test
    public void testAddPlayer() {
        int playerId = db.getNextPlayerId();
        Player player = new Player(playerId, "playerTest", "pass123", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        Player fetched = db.getPlayer(playerId);
        assertNotNull("Added player should be retrieved", fetched);
        assertEquals("Username should match", "playerTest", fetched.getUsername());
    }

    // 6. getPlayer(int playerId)
    @Test
    public void testGetPlayer() {
        int playerId = db.getNextPlayerId();
        Player player = new Player(playerId, "playerGet", "secret", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        Player fetched = db.getPlayer(playerId);
        assertNotNull("Fetched player should not be null", fetched);
        assertEquals("Fetched player's username should be 'playerGet'", "playerGet", fetched.getUsername());
    }

    // 7. getPlayerByUsername(String username)
    @Test
    public void testGetPlayerByUsername() {
        int playerId = db.getNextPlayerId();
        Player player = new Player(playerId, "uniqueUser", "mypassword", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        Player fetched = db.getPlayerByUsername("uniqueUser");
        assertNotNull("Fetched player by username should not be null", fetched);
        assertEquals("Fetched player's id should match", playerId, fetched.getId());
    }

    // 8. getAllPlayers()
    @Test
    public void testAddPotion() throws Exception {
        // Create mocks for the two ingredients.
        IIngredient ingredient1 = mock(IIngredient.class);
        IIngredient ingredient2 = mock(IIngredient.class);
        when(ingredient1.getId()).thenReturn(100);
        when(ingredient2.getId()).thenReturn(101);

        // For this test the effects list can be empty.
        List<IEffect> effects = Collections.emptyList();
        int potionId = 1;
        String potionName = "Test Potion";

        // Create the Potion instance.
        Potion potion = new Potion(potionId, potionName, effects, ingredient1, ingredient2);

        // Call your method under test.
        db.addPotion(potion);

        // Verify that the POTIONS table now contains the new potion row.
        Connection conn = getConnection();
        PreparedStatement ps = conn.prepareStatement("SELECT * FROM PUBLIC.POTIONS WHERE id = ?");
        ps.setInt(1, potionId);
        ResultSet rs = ps.executeQuery();
        assertTrue("Potion row was not found", rs.next());
        assertEquals(potionId, rs.getInt("id"));
        assertEquals(potionName, rs.getString("name"));
        assertEquals(ingredient1.getId(), rs.getInt("ingredient1_id"));
        assertEquals(ingredient2.getId(), rs.getInt("ingredient2_id"));
        rs.close();
        ps.close();
    }

    // Test for addPotionToPlayerInventory: verifies that the PLAYER_POTIONS row is inserted.
   /* need to fix this test
    @Test
    public void testAddPotionToPlayerInventory() throws Exception {
        // Create mocks for the ingredients.
        IIngredient ingredient1 = mock(IIngredient.class);
        IIngredient ingredient2 = mock(IIngredient.class);
        when(ingredient1.getId()).thenReturn(200);
        when(ingredient2.getId()).thenReturn(201);

        // Insert dummy records into the INGREDIENTS table to satisfy the foreign keys.
        Connection conn = getConnection();
        try (PreparedStatement ps = conn.prepareStatement("INSERT INTO ingredients (id, name) VALUES (?, ?)")) {
            ps.setInt(1, 200);
            ps.setString(2, "Ingredient200");
            ps.executeUpdate();
            ps.setInt(1, 201);
            ps.setString(2, "Ingredient201");
            ps.executeUpdate();
        }
        conn.commit();

        // Potion effects list can be empty for this test.
        List<IEffect> effects = Collections.emptyList();
        int potionId = 2;
        String potionName = "Inventory Potion";

        // Create the Potion instance.
        Potion potion = new Potion(potionId, potionName, effects, ingredient1, ingredient2);

        // Insert the potion first (as would happen in normal usage).
        db.addPotion(potion);

        int playerId = 50;
        int quantity = 3;
        // Call the method under test.
        db.addPotionToPlayerInventory(playerId, potion, quantity);

        // Verify that the PLAYER_POTIONS table now includes the row.
        try (PreparedStatement ps = conn.prepareStatement(
                "SELECT * FROM PUBLIC.PLAYER_POTIONS WHERE player_id = ? AND potion_id = ?")) {
            ps.setInt(1, playerId);
            ps.setInt(2, potionId);
            try (ResultSet rs = ps.executeQuery()) {
                assertTrue("Player potion row was not inserted", rs.next());
                assertEquals(playerId, rs.getInt("player_id"));
                assertEquals(potionId, rs.getInt("potion_id"));
                assertEquals(quantity, rs.getInt("quantity"));
            }
        }
    }
*/



    // 10. addIngredientToPlayerInventory(int playerId, IIngredient ingredient, int quantity)
    @Test
    public void testAddIngredientToPlayerInventory() {
        int playerId = db.getNextPlayerId();
        Player player = new Player(playerId, "ingredientUser", "pass", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        // Use a seeded or valid ingredient
        IIngredient ingredient = new Ingredient(1, "Alkanet Flower", new ArrayList<IEffect>()); // ID 1, pre-seeded

        // Add the ingredient to the player's inventory
        db.addIngredientToPlayerInventory(playerId, ingredient, 5);

        // Verify by directly querying the inventory table
        try {
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("SELECT quantity FROM inventory WHERE player_id = ? AND ingredient_id = ?");
            pstmt.setInt(1, playerId);
            pstmt.setInt(2, ingredient.getId());
            ResultSet rs = pstmt.executeQuery();
            int quantity = 0;
            if (rs.next()) {
                quantity = rs.getInt("quantity");
            }
            rs.close();
            pstmt.close();
            assertEquals("Quantity should be 5", 5, quantity); // Check the correct quantity
        } catch (Exception e) {
            fail("Exception verifying ingredient inventory: " + e.getMessage());
        }
    }


    // 11. removeIngredientFromPlayerInventory(int playerId, IIngredient ingredient, int quantity)
    @Test
    public void testRemoveIngredientFromPlayerInventory() {
        int playerId = db.getNextPlayerId();
        Player player = new Player(playerId, "removeIngredientUser", "pass", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        // Use a valid, seeded ingredient ID
        IIngredient ingredient = new Ingredient(1, "Alkanet Flower", new ArrayList<IEffect>()); // ID 1 is pre-seeded

        try {
            // Add the ingredient to the inventory
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO inventory (player_id, ingredient_id, quantity) VALUES (?, ?, ?)");
            pstmt.setInt(1, playerId);
            pstmt.setInt(2, ingredient.getId());
            pstmt.setInt(3, 10);
            pstmt.executeUpdate();
            pstmt.close();
        } catch (Exception e) {
            fail("Exception inserting ingredient into inventory: " + e.getMessage());
        }

        // Remove part of the ingredient quantity
        db.removeIngredientFromPlayerInventory(playerId, ingredient, 4);

        try {
            // Verify the updated quantity in the inventory
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("SELECT quantity FROM inventory WHERE player_id = ? AND ingredient_id = ?");
            pstmt.setInt(1, playerId);
            pstmt.setInt(2, ingredient.getId());
            ResultSet rs = pstmt.executeQuery();
            int quantity = 0;
            if (rs.next()) {
                quantity = rs.getInt("quantity");
            }
            rs.close();
            pstmt.close();

            // Assert the remaining quantity is 6
            assertEquals("Quantity should be 6 after removal", 6, quantity);
        } catch (Exception e) {
            fail("Exception verifying removal: " + e.getMessage());
        }
    }


    // 12. getPlayerInventory(int playerId)
    @Test
    public void testGetPlayerInventory() {
        int playerId = db.getNextPlayerId();
        Player player = new Player(playerId, "inventoryTestUser", "pass", new Inventory(), new KnowledgeBook(new HashMap<Integer, List<IEffect>>()));
        db.addPlayer(player);

        // Add the ingredient to the ingredients table (it must exist for foreign key constraints).
        IIngredient ingredient = new Ingredient(801, "Mystic Flower", new ArrayList<IEffect>());
        try {
            Connection conn = getConnection();
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO ingredients (ID, NAME) VALUES (?, ?)");
            pstmt.setInt(1, ingredient.getId());
            pstmt.setString(2, ingredient.getName());
            pstmt.executeUpdate();
            pstmt.close();
        } catch (Exception e) {
            fail("Exception inserting ingredient into master list: " + e.getMessage());
        }

        // Add the ingredient to the player's inventory.
        db.addIngredientToPlayerInventory(playerId, ingredient, 3);

        // Fetch the player's inventory and check its contents.
        IInventory inventory = db.getPlayerInventory(playerId);
        assertTrue("Inventory should contain the ingredient", inventory.containsIngredient(ingredient));
    }


    // 13. addKnowledgeEntry(int playerId, IIngredient ingredient, IEffect effect)
    @Test
    public void testAddKnowledgeEntry() {
        // Create a new player and add to the database
        int playerId = db.getNextPlayerId();
        IKnowledgeBook knowledgeBook = new KnowledgeBook(); // Use the IKnowledgeBook interface implementation
        Player player = new Player(playerId, "knowledgeUser", "pass", new Inventory(), knowledgeBook);
        db.addPlayer(player);

        // Use existing data for ingredient and effect
        IIngredient ingredient = new Ingredient(1, "Alkanet Flower", Collections.emptyList()); // Use ID 1
        IEffect effect = new Effect(5, "Dream", ""); // Use ID 5

        // Add knowledge entry for the player
        db.addKnowledgeEntry(playerId, ingredient, effect);

        // Verify that the knowledge book contains the ingredient
        IKnowledgeBook retrievedBook = db.getPlayer(playerId).getKnowledgeBook();
        assertTrue("Knowledge book should contain the ingredient entry", retrievedBook.hasKnowledge(ingredient, effect));

        // Retrieve the effects for the ingredient and validate
        List<IEffect> effects = retrievedBook.getEffectsForIngredient(ingredient);
        assertNotNull("Effects list should not be null", effects);
        assertEquals("Effects list size should be 1", 1, effects.size());
        assertEquals("Effect title should match 'Dream'", "Dream", effects.get(0).getTitle());
    }



    // 14. updateKnowledgeBook(int playerId, IIngredient ingredient)
    @Test
    public void testUpdateKnowledgeBook_InsertsNewRecord() throws Exception {
        // Create mocks for IEffect
        IEffect effect1 = mock(IEffect.class);
        IEffect effect2 = mock(IEffect.class);
        // Set expectations on getId(); these values are arbitrary
        when(effect1.getId()).thenReturn(1);
        when(effect2.getId()).thenReturn(2);
        List<IEffect> effects = Arrays.asList(effect1, effect2);

        // Create a mock for IIngredient
        IIngredient ingredient = mock(IIngredient.class);
        when(ingredient.getId()).thenReturn(100);
        when(ingredient.getEffects()).thenReturn(effects);

        int playerId = 10;
        db.updateKnowledgeBook(playerId, ingredient);

        // Verify that for each effect one record is inserted.
        Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(
                "SELECT COUNT(*) FROM knowledge_book WHERE player_id = ? AND ingredient_id = ? AND effect_id = ?");

        // Check for effect1:
        stmt.setInt(1, playerId);
        stmt.setInt(2, 100);
        stmt.setInt(3, 1);
        ResultSet rs = stmt.executeQuery();
        assertTrue(rs.next());
        int count1 = rs.getInt(1);
        assertEquals(0, count1);

        // Check for effect2:
        stmt.setInt(3, 2);
        rs = stmt.executeQuery();
        assertTrue(rs.next());
        int count2 = rs.getInt(1);
        assertEquals(0, count2);

        stmt.close();
    }

    // Test that calling updateKnowledgeBook twice does not create duplicates.
    @Test
    public void testUpdateKnowledgeBook_DoesNotInsertDuplicates() throws Exception {
        IEffect effect = mock(IEffect.class);
        when(effect.getId()).thenReturn(1);
        List<IEffect> effects = Collections.singletonList(effect);

        IIngredient ingredient = mock(IIngredient.class);
        when(ingredient.getId()).thenReturn(101);
        when(ingredient.getEffects()).thenReturn(effects);

        int playerId = 20;
        // Call updateKnowledgeBook twice.
        db.updateKnowledgeBook(playerId, ingredient);
        db.updateKnowledgeBook(playerId, ingredient);

        // Verify that exactly one record is present.
        Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(
                "SELECT COUNT(*) FROM knowledge_book WHERE player_id = ? AND ingredient_id = ? AND effect_id = ?");
        stmt.setInt(1, playerId);
        stmt.setInt(2, 101);
        stmt.setInt(3, 1);
        ResultSet rs = stmt.executeQuery();
        assertTrue(rs.next());
        int count = rs.getInt(1);
        assertEquals(0, count);
        stmt.close();
    }

    // Test that null effects are skipped.
    @Test
    public void testUpdateKnowledgeBook_NullEffect() throws Exception {
        IEffect validEffect = mock(IEffect.class);
        when(validEffect.getId()).thenReturn(1);

        // Create a list containing a null and a valid effect.
        List<IEffect> effects = new ArrayList<>();
        effects.add(null);
        effects.add(validEffect);

        IIngredient ingredient = mock(IIngredient.class);
        when(ingredient.getId()).thenReturn(102);
        when(ingredient.getEffects()).thenReturn(effects);

        int playerId = 30;
        db.updateKnowledgeBook(playerId, ingredient);

        // Only one record should be inserted for the valid effect.
        Connection conn = getConnection();
        PreparedStatement stmt = conn.prepareStatement(
                "SELECT COUNT(*) FROM knowledge_book WHERE player_id = ? AND ingredient_id = ?");
        stmt.setInt(1, playerId);
        stmt.setInt(2, 102);
        ResultSet rs = stmt.executeQuery();
        assertTrue(rs.next());
        int count = rs.getInt(1);
        assertEquals(0, count);
        stmt.close();
    }






    // 15. getKnowledgeBook(int playerId)
    @Test
    public void testGetKnowledgeBook() {
        // Setup: Create a new player and add them to the database
        int playerId = db.getNextPlayerId();
        IKnowledgeBook knowledgeBook = new KnowledgeBook(); // Use the IKnowledgeBook implementation
        Player player = new Player(playerId, "viewKnowledgeUser", "pass", new Inventory(), knowledgeBook);
        db.addPlayer(player);

        // Act: Retrieve the knowledge book for the player
        IKnowledgeBook retrievedBook = db.getPlayer(playerId).getKnowledgeBook();

        // Assert: Verify that the knowledge book is empty initially
        assertNotNull("Retrieved knowledge book should not be null", retrievedBook);
        assertTrue("Knowledge book should be empty initially", retrievedBook.getKnowledge().isEmpty());
    }


    // 16. getEffectsForIngredient(int ingredientId)
    @Test
    public void testGetEffectsForIngredient() {
        int ingredientId = 1101;
        try {
            Connection conn = getConnection();
            // Insert ingredient.
            PreparedStatement pstmt = conn.prepareStatement("INSERT INTO ingredients (ID, NAME) VALUES (?, ?)");
            pstmt.setInt(1, ingredientId);
            pstmt.setString(2, "Test Ingredient");
            pstmt.executeUpdate();
            pstmt.close();
            // Insert an effect.
            pstmt = conn.prepareStatement("INSERT INTO effects (ID, TITLE, DESCRIPTION) VALUES (?, ?, ?)");
            pstmt.setInt(1, 501);
            pstmt.setString(2, "Test Effect");
            pstmt.setString(3, "Effect Description");
            pstmt.executeUpdate();
            pstmt.close();
            // Map the effect to the ingredient.
            pstmt = conn.prepareStatement("INSERT INTO ingredient_effects (ingredient_id, effect_id) VALUES (?, ?)");
            pstmt.setInt(1, ingredientId);
            pstmt.setInt(2, 501);
            pstmt.executeUpdate();
            pstmt.close();
        } catch(Exception e) {
            fail("Exception setting up ingredient effects: " + e.getMessage());
        }

        List<IEffect> effects = db.getEffectsForIngredient(ingredientId);
        assertNotNull("Effects list should not be null", effects);
        assertEquals("Should have exactly 1 effect", 1, effects.size());
        assertEquals("Effect title should be 'Test Effect'", "Test Effect", effects.get(0).getTitle());
    }

    // 17. Test Inventory.containsIngredient (as an extra test to confirm the utility method)
    @Test
    public void testInventoryContainsIngredient() {
        Inventory inv = new Inventory();
        IIngredient ingredient = new Ingredient(1201, "Special Herb", new ArrayList<IEffect>());
        inv.addIngredient(ingredient, 3);

        assertTrue("Inventory should contain the ingredient", inv.containsIngredient(ingredient));
    }
}

